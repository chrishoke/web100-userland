NOTE
====

THIS IS THE DEVELOPER'S GUIDE FROM A PREVIOUS VERSION OF WEB100 (0.3).  AN
UPDATED VERSION WILL APPEAR IN A SUBSEQUENT RELEASE OF WEB100.

Intro

The following provides examples and suggestions for those interested in writing
applications using the web100 library API. This is an Alpha0 release of the API,
and there will certainly be tweaks in subsequent releases, however, the basic
form is presumed stable, so that future modifications necessitated at the
application level should be minor. Application programmers may rely on the
library API for development, though may want to familiarize themselves with
issues at the level of the kernel API; for this, one should refer to the
document proc_interface.txt to be found in 

/usr/src/linux/Documentation/web100

after installing the Web100 patch.

HelloWeb100

What follows is an example of a "Hello World" program using the web100 library
API; one will recognize this as the basis for deltavar, respectively vdt
(Variable Display Tool), contained in the utils distribution. The following
example takes a connection ID (= directory name in /proc/web100 referring to the
connection) and a Kernel Instrument Set variable name (in this case, any of
those under "/read" in /proc/web100/header) on the command line and prints the
resulting value and delta once a second.

/*** Begin HelloWeb100.c: gcc -o HelloWeb100 HelloWeb100.c web100lib.c ***/

#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>

#include"web100.h" 

struct web100_agent *agent;
struct web100_connection *conn;
struct web100_snap *snap;
struct web100_var *wv;
unsigned int value, delta;
unsigned char addr[4];

void init(char *cid, char *varname)
{
  /*
   * Define the web100_agent for the session. Memory for struct web100_agent
   * is allocated, as is that for all web100_vars defined in
   * /proc/web100/header. The returned agent references a list of web100_file's,
   * each of which refers to the comprising web100_vars.
   */
  agent = web100_attach("localhost");
  /*
   * Define an instance of web100_connection in terms of the procured agent
   * and the connection ID. Memory for the web100_connection struct is
   * allocated.
   */
  conn = web100_find_connection(agent, cid);
  /*
   * Take an initial snapshot of the elements of the Kernel Instrument Set
   * referred to by "web100_def_file". This implicitly allocates memory
   * for struct web100_snap and sets priorsnap = lastsnap, lastsnap = snap.
   */ 
  snap = web100_get_snapshot(conn, web100_def_file);
  /* 
   * Locate the web100_var by name for the given connection.
   */
  wv = web100_find_var(conn, varname); 
}

/*
 * After init, each future update manages the obsoleted prior snapshot, and
 * takes a new snapshot; after the first update, web100_delta_anyXX returns 
 * meaningful results (since at that point, both lastsnap, priorsnap refer
 * to read values).
 */
void update(void)
{
  if(priorsnap) free(priorsnap); 
  snap = web100_get_snapshot(conn, web100_def_file);
}

/* 
 *  The web100 library is strongly typed; herein, values/deltas are read for
 *  the appropriate wv->type and the results printed.
 */ 
void print_result(void)
{ 
  switch (wv->type) {
    case TYPE_INTEGER:
      value=web100_get_integer(wv, snap);
      delta=web100_delta_integer(wv, lastsnap, priorsnap);
      printf("%u %u ", value, delta);
      break;

    case TYPE_INTEGER32:
      value=web100_get_integer32(wv, snap);
      delta=web100_delta_integer32(wv, lastsnap, priorsnap);
      printf("%u %u ", value, delta);
      break;

    case TYPE_COUNTER32:
      value=web100_get_counter32(wv, snap);
      delta=web100_delta_counter32(wv, lastsnap, priorsnap);
      printf("%u %u ", value, delta);
      break;

    case TYPE_GAUGE32:
      value=web100_get_gauge32(wv, snap);
      delta=web100_delta_gauge32(wv, lastsnap, priorsnap);
      printf("%u %u ", value, delta);
      break;

    case TYPE_UNSIGNED32:
      value=web100_get_unsigned32(wv, snap);
      delta=web100_delta_unsigned32(wv, lastsnap, priorsnap);
      printf("%u %u ", value, delta);
      break;

    case TYPE_TIME_TICKS:
      value=web100_get_time_ticks(wv, snap);
      delta=web100_delta_time_ticks(wv, lastsnap, priorsnap);
      printf("%u %u ", value, delta);
      break;

    case TYPE_IP_ADDRESS:
      web100_get_IPv4_address(wv, snap, addr);
      printf("%u.%u.%u.%u - ", addr[0], addr[1], addr[2], addr[3]);
      break;

    case TYPE_UNSIGNED16:
      value=web100_get_unsigned16(wv, snap);
      delta=web100_delta_unsigned16(wv, lastsnap, priorsnap);
      printf("%u %u ", value, delta);
      break;

    /* XXX In general we can not handle 64 bits */
    case TYPE_COUNTER64:
    default:
      printf("??%s(%d) ", wv->name, wv->type); 
  }
  printf("\n");
}

int main(int argc, char *argv[])
{
  if (argc < 3) {
    printf("Usage: HelloWeb100 ConnectionID VarName\n");
    exit(2);
  }
  init(argv[1], argv[2]);
  while(1){
    update();
    print_result();
    sleep(1);
  } 
}

/*** End HelloWeb100.c ***/

Remark:

The instances "lastsnap", "priorsnap" are provided for implicit delta management;
the caller need only manage garbage collection for prior priorsnap's (so to
speak). Note that if one has an application taking snapshots of variables for
several connections, management of last/priorsnap's will need to be done at the
application level, e.g.:

struct web100_snap snap_1, lastsnap_1=NULL, priorsnap_1=NULL;
struct web100_snap snap_2, lastsnap_2=NULL, priorsnap_2=NULL;
...
snap_1 = web100_get_snapshot(conn_1, web100_def_file);
priorsnap_1 = lastsnap_1; lastsnap_1 = snap_1;

snap_2 = web100_get_snapshot(conn_2, web100_def_file);
priorsnap_2 = lastsnap_2; lastsnap_2 = snap_2;
...
free(priorsnap_1);
snap_1 = web100_get_snapshot(conn_1, web100_def_file);
priorsnap_1 = lastsnap_1; lastsnap_1 = snap_1;
delta_1 = web100_delta_anyXX(variable, lastsnap_1, priorsnap_1); 
...etc.


Gui matters:

Several of the applications in the utils distribution use the Gtk library; these
are described in the users-guide.web100. For those interested in writing
applications using Gtk, the next release will contain widget versions of the
applications contained therein, suitable for invoking from applications written
in a language bound to Gtk. For those interested in using Gtk, see the
documentation at www.gtk.org.


API reference:
...










